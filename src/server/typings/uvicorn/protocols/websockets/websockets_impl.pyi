"""
This type stub file was generated by pyright.
"""

import websockets

class Server:
    closing = ...
    def register(self, ws): # -> None:
        ...
    
    def unregister(self, ws): # -> None:
        ...
    
    def is_serving(self): # -> bool:
        ...
    


class WebSocketProtocol(websockets.WebSocketServerProtocol):
    def __init__(self, config, server_state, _loop=...) -> None:
        ...
    
    def connection_made(self, transport): # -> None:
        ...
    
    def connection_lost(self, exc): # -> None:
        ...
    
    def shutdown(self): # -> None:
        ...
    
    def on_task_complete(self, task): # -> None:
        ...
    
    async def process_request(self, path, headers): # -> tuple[Literal[HTTPStatus.FORBIDDEN], list[Unknown], Literal[b'']] | None:
        """
        This hook is called to determine if the websocket should return
        an HTTP response and close.

        Our behavior here is to start the ASGI application, and then wait
        for either `accept` or `close` in order to determine if we should
        close the connection.
        """
        ...
    
    def process_subprotocol(self, headers, available_subprotocols): # -> None:
        """
        We override the standard 'process_subprotocol' behavior here so that
        we return whatever subprotocol is sent in the 'accept' message.
        """
        ...
    
    def send_500_response(self): # -> None:
        ...
    
    async def ws_handler(self, protocol, path): # -> None:
        """
        This is the main handler function for the 'websockets' implementation
        to call into. We just wait for close then return, and instead allow
        'send' and 'receive' events to drive the flow.
        """
        ...
    
    async def run_asgi(self): # -> None:
        """
        Wrapper around the ASGI callable, handling exceptions and unexpected
        termination states.
        """
        ...
    
    async def asgi_send(self, message):
        ...
    
    async def asgi_receive(self): # -> dict[str, str] | dict[str, str | Unknown | int] | dict[str, str | Unknown]:
        ...
    


